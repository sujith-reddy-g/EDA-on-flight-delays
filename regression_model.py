# -*- coding: utf-8 -*-
"""Regression_Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13NMotXN6rVlHjm1TCwPQmJaRTbVcg6KV

### **Linear Regression**
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install pyspark

import pyspark
print(pyspark.__version__)

from pyspark.sql import SparkSession
from pyspark.sql.types import *


spark = SparkSession.builder \
    .appName("project") \
    .config("spark.executor.memory", "4g") \
    .config("spark.driver.memory", "2g") \
    .config("spark.memory.fraction", "0.6") \
    .config("spark.memory.storageFraction", "0.5") \
    .config("spark.executor.extraJavaOptions", "-XX:+UseG1GC") \
    .config("spark.driver.extraJavaOptions", "-XX:+UseG1GC") \
    .master("local[4]") \
    .getOrCreate()

from pyspark.sql.functions import col, when, count, mean
from pyspark.sql.types import *
import pandas as pd

df_all = spark.read.csv('/content/drive/MyDrive/itc686_project/*', header=True)

df_selective = df_all['Year', 'Month', 'DayofMonth', 'DayOfWeek',
            'DepTime', 'CRSDepTime', 'ArrTime', 'CRSArrTime',
            'Marketing_Airline_Network', 'Flight_Number_Marketing_Airline',
            'Tail_Number', 'ActualElapsedTime', 'CRSElapsedTime',
            'AirTime', 'ArrDelay', 'DepDelay', 'Origin', 'Dest',
            'Distance', 'TaxiIn', 'TaxiOut', 'Cancelled',
            'CancellationCode','CarrierDelay',
            'WeatherDelay', 'NASDelay', 'SecurityDelay',
            'LateAircraftDelay','Operating_Airline ','DepDelayMinutes']

schema_types = {
    "Year": IntegerType(),
    "Month": IntegerType(),
    "DayofMonth": IntegerType(),
    "DayOfWeek": IntegerType(),
    "DepTime": IntegerType(),
    "CRSDepTime": IntegerType(),
    "ArrTime": IntegerType(),
    "CRSArrTime": IntegerType(),
    "Marketing_Airline_Network": StringType(),
    "Flight_Number_Marketing_Airline": IntegerType(),
    "Tail_Number": StringType(),
    "ActualElapsedTime": IntegerType(),
    "CRSElapsedTime": IntegerType(),
    "AirTime": IntegerType(),
    "ArrDelay": IntegerType(),
    "DepDelay": IntegerType(),
    "Origin": StringType(),
    "Dest": StringType(),
    "Distance": IntegerType(),
    "TaxiIn": IntegerType(),
    "TaxiOut": IntegerType(),
    "Cancelled": IntegerType(),
    "CancellationCode": StringType(),
    "CarrierDelay": IntegerType(),
    "WeatherDelay": IntegerType(),
    "NASDelay": IntegerType(),
    "SecurityDelay": IntegerType(),
    "LateAircraftDelay": IntegerType(),
    'Operating_Airline ': StringType(),
    'DepDelayMinutes':IntegerType()
}

for column, dtype in schema_types.items():
    if isinstance(dtype, IntegerType):
        df_selective = df_selective.withColumn(column, col(column).cast("int"))

df_selective=df_selective.dropna(how='any',subset=['Tail_Number','Origin','Dest',"DepDelay", "ArrDelay",'AirTime'])
df_delay= df_selective.filter(col('ArrDelay')>=15)
df_cancelled=df_selective.filter((col('Cancelled') == 1) & ~col('CancellationCode').isNull())

from pyspark.ml.feature import VectorAssembler
from pyspark.ml.regression import LinearRegression
from pyspark.ml.evaluation import RegressionEvaluator
from pyspark.ml import Pipeline

from pyspark.sql.functions import col, isnan, when, count

# Checking for null or NaN values in ActualElapsedTime
df_selective.select([count(when(isnan(col(c)) | col(c).isNull(), c)).alias(c) for c in ["ActualElapsedTime"]]).show()


# Option 1: Removing rows where ActualElapsedTime is null or NaN
df_clean = df_selective.filter(df_selective.ActualElapsedTime.isNotNull())

# Option 2: Filling NaN or null values with the mean or a specific value (e.g., the mean of ActualElapsedTime)
mean_value = df_selective.agg({"ActualElapsedTime": "mean"}).first()[0]
df_filled = df_selective.na.fill({'ActualElapsedTime': mean_value})

# Proceed with your existing code, using df_clean or df_filled instead of df_selective
feature_cols = ['CRSElapsedTime', 'Distance']
assembler = VectorAssembler(inputCols=feature_cols, outputCol="features")
lr = LinearRegression(featuresCol='features', labelCol='ActualElapsedTime')
pipeline = Pipeline(stages=[assembler, lr])


# Split the data into training and testing sets
train_data, test_data = df_filled.randomSplit([0.8, 0.2], seed=42)

# Train the model
model = pipeline.fit(train_data)

# Make predictions on the test data
predictions_m = model.transform(test_data)

# Show some prediction results
predictions_m.select("features", "ActualElapsedTime", "prediction").show(5)

# Print the coefficients and intercept
print("Coefficients: " + str(model.stages[-1].coefficients))
print("Intercept: " + str(model.stages[-1].intercept))

predictions=predictions_m.select("prediction", "ActualElapsedTime").toPandas()

# Create regression evaluators
evaluator_rmse = RegressionEvaluator(labelCol="ActualElapsedTime", predictionCol="prediction", metricName="rmse")
evaluator_mae = RegressionEvaluator(labelCol="ActualElapsedTime", predictionCol="prediction", metricName="mae")
evaluator_r2 = RegressionEvaluator(labelCol="ActualElapsedTime", predictionCol="prediction", metricName="r2")

# Calculate RMSE, MAE, and R^2
rmse = evaluator_rmse.evaluate(predictions_m)
mae = evaluator_mae.evaluate(predictions_m)
r2 = evaluator_r2.evaluate(predictions_m)

# Print the results
print(f"Root Mean Squared Error (RMSE): {rmse}")
print(f"Mean Absolute Error (MAE): {mae}")
print(f"R^2: {r2}")

pip install matplotlib seaborn

import matplotlib.pyplot as plt
import seaborn as sns



# Calculate residuals
predictions['Residuals'] = predictions['ActualElapsedTime'] - predictions['prediction']

# Plot residuals
plt.figure(figsize=(10, 6))
plt.scatter(predictions['prediction'], predictions['Residuals'], alpha=0.5)
plt.title('Residuals vs. Predicted')
plt.xlabel('Predicted Values')
plt.ylabel('Residuals')
plt.axhline(y=0, color='r', linestyle='--')
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(x=predictions['ActualElapsedTime'], y=predictions['prediction'])
plt.plot([predictions['ActualElapsedTime'].min(), predictions['ActualElapsedTime'].max()],
         [predictions['ActualElapsedTime'].min(), predictions['ActualElapsedTime'].max()],
         color='red', lw=2, linestyle='--')
plt.title('Actual vs. Predicted')
plt.xlabel('Actual')
plt.ylabel('Predicted')
plt.show()

plt.figure(figsize=(10, 6))
sns.histplot(predictions['Residuals'], bins=30, kde=True)
plt.title('Distribution of Residuals')
plt.xlabel('Residuals')
plt.ylabel('Frequency')
plt.show()